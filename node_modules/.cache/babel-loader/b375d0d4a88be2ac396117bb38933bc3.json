{"ast":null,"code":"import _slicedToArray from\"C:/wamp64/www/gamereact11/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";import{getCounter}from'./helpers';var min=function min(num){return Math.max(num-3,0);};var max=function max(num,_max){return Math.min(num+3,_max);};// chek for win inspired by https://stackoverflow.com/questions/32770321/connect-4-check-for-a-win-algorithm\nvar getWinner=function getWinner(firstSegment,secondSegment,thirdegment,fourthSegment,gameGrid,turn){var segments=[firstSegment,secondSegment,thirdegment,fourthSegment];// check if where is more then 4 coutners in segement\nif(segments.length!==4)return false;var counters=segments.map(function(_ref){var _ref2=_slicedToArray(_ref,2),row=_ref2[0],col=_ref2[1];// get counter from game board\nreturn getCounter(row,col,gameGrid);});// get color\nvar color=counters[0];// if there is no color --> segment is not completed\nif(!color)return false;// if every color in segment is the same is win retrun\n// winner color and win combo segemnts\nif(counters.every(function(c){return c===turn;})){return{winner:turn,segments:segments};}return false;};// Check for all possible horizontal segmetns near counter that were places\nvar checkHorizontalSegments=function checkHorizontalSegments(_ref3,gameGrid,turn){var focalRow=_ref3.focalRow,minCol=_ref3.minCol,maxCol=_ref3.maxCol,focalCol=_ref3.focalCol;for(var row=focalRow,col=minCol;col<=maxCol;col++){// Check segment for win\nvar winner=getWinner([row,col],[row,col+1],[row,col+2],[row,col+3],gameGrid,turn);if(winner)return winner;}return false;};// Check for all possible vertical segmetns near counter that were places\nvar checkVerticalSegments=function checkVerticalSegments(_ref4,gameGrid,turn){var focalRow=_ref4.focalRow,focalCol=_ref4.focalCol,minRow=_ref4.minRow,maxRow=_ref4.maxRow;for(var col=focalCol,row=minRow;row<=focalRow;row++){var winner=getWinner([row,col],[row+1,col],[row+2,col],[row+3,col],gameGrid,turn);if(winner)return winner;}return false;};// Check for all possible diagonal \\ near counter that were places\nvar checkForwardSlashSegments=function checkForwardSlashSegments(_ref5,gameGrid,turn){var focalRow=_ref5.focalRow,focalCol=_ref5.focalCol,minRow=_ref5.minRow,minCol=_ref5.minCol,maxRow=_ref5.maxRow,maxCol=_ref5.maxCol;var startForwardSlash=function startForwardSlash(row,col){while(row>minRow&&col>minCol){row--;col--;}return[row,col];};for(var _startForwardSlash=startForwardSlash(focalRow,focalCol),_startForwardSlash2=_slicedToArray(_startForwardSlash,2),row=_startForwardSlash2[0],col=_startForwardSlash2[1];row<=maxRow&&col<=maxCol;row++,col++){var winner=getWinner([row,col],[row+1,col+1],[row+2,col+2],[row+3,col+3],gameGrid,turn);if(winner)return winner;}return false;};// Check for all possible diagonal / near counter that were places\nvar checkBackwardSlashSegments=function checkBackwardSlashSegments(_ref6,gameGrid,turn){var focalRow=_ref6.focalRow,focalCol=_ref6.focalCol,minRow=_ref6.minRow,minCol=_ref6.minCol,maxRow=_ref6.maxRow,maxCol=_ref6.maxCol;var startBackwardSlash=function startBackwardSlash(row,col){while(row<maxRow&&col>minCol){row++;col--;}return[row,col];};for(var _startBackwardSlash=startBackwardSlash(focalRow,focalCol),_startBackwardSlash2=_slicedToArray(_startBackwardSlash,2),row=_startBackwardSlash2[0],col=_startBackwardSlash2[1];row>=minRow&&col<=maxCol;row--,col++){var winner=getWinner([row,col],[row-1,col+1],[row-2,col+2],[row-3,col+3],gameGrid,turn);if(winner)return winner;}return false;};export var checkForWin=function checkForWin(focalRow,focalCol,gameGrid,turn){// difenes min and max columns and rows for particular counter\n//  0  1  2  3  4  5  6\n// [ ][ ][ ][ ][ ][ ][ ] 0\n// [x][our counter][x][x][ ][ ][ ] 1\n// [ ][ ][ ][ ][ ][ ][ ] 2\n// [ ][ ][ ][ ][ ][ ][ ] 3\n// [ ][ ][ ][ ][ ][ ][ ] 4\n// [ ][ ][ ][ ][ ][ ][ ] 5\nvar minCol=min(focalCol);var maxCol=max(focalCol,6);var minRow=min(focalRow);var maxRow=max(focalRow,5);var coords={focalRow:focalRow,focalCol:focalCol,minRow:minRow,minCol:minCol,maxRow:maxRow,maxCol:maxCol};return checkHorizontalSegments(coords,gameGrid,turn)||checkVerticalSegments(coords,gameGrid,turn)||checkForwardSlashSegments(coords,gameGrid,turn)||checkBackwardSlashSegments(coords,gameGrid,turn);};","map":{"version":3,"names":["getCounter","min","num","Math","max","getWinner","firstSegment","secondSegment","thirdegment","fourthSegment","gameGrid","turn","segments","length","counters","map","row","col","color","every","c","winner","checkHorizontalSegments","focalRow","minCol","maxCol","focalCol","checkVerticalSegments","minRow","maxRow","checkForwardSlashSegments","startForwardSlash","checkBackwardSlashSegments","startBackwardSlash","checkForWin","coords"],"sources":["C:/wamp64/www/gamereact11/src/helpers/checkForWin.ts"],"sourcesContent":["import { counter } from './helpers';\nimport { getCounter } from './helpers';\n\ntype coordinates = {\n  focalRow: number;\n  focalCol: number;\n  minRow: number;\n  minCol: number;\n  maxRow: number;\n  maxCol: number;\n};\n\ntype winComb = {\n  winner: string | null;\n  segments: number[][];\n};\n\nconst min = (num: number): number => Math.max(num - 3, 0);\nconst max = (num: number, max: number): number => Math.min(num + 3, max);\n\n// chek for win inspired by https://stackoverflow.com/questions/32770321/connect-4-check-for-a-win-algorithm\n\nconst getWinner = (\n  firstSegment: number[],\n  secondSegment: number[],\n  thirdegment: number[],\n  fourthSegment: number[],\n  gameGrid: counter[][],\n  turn: string\n): boolean | winComb => {\n  const segments = [firstSegment, secondSegment, thirdegment, fourthSegment];\n  // check if where is more then 4 coutners in segement\n  if (segments.length !== 4) return false;\n  let counters = segments.map(([row, col]) => {\n    // get counter from game board\n    return getCounter(row, col, gameGrid);\n  });\n\n  // get color\n  const color = counters[0];\n  // if there is no color --> segment is not completed\n  if (!color) return false;\n  // if every color in segment is the same is win retrun\n  // winner color and win combo segemnts\n  if (counters.every((c) => c === turn)) {\n    return { winner: turn, segments };\n  }\n\n  return false;\n};\n\n// Check for all possible horizontal segmetns near counter that were places\nconst checkHorizontalSegments = (\n  { focalRow, minCol, maxCol, focalCol }: coordinates,\n  gameGrid: counter[][],\n  turn: string\n) => {\n  for (let row = focalRow, col = minCol; col <= maxCol; col++) {\n    // Check segment for win\n    const winner = getWinner(\n      [row, col],\n      [row, col + 1],\n      [row, col + 2],\n      [row, col + 3],\n      gameGrid,\n      turn\n    );\n\n    if (winner) return winner;\n  }\n  return false;\n};\n\n// Check for all possible vertical segmetns near counter that were places\n\nconst checkVerticalSegments = (\n  { focalRow, focalCol, minRow, maxRow }: coordinates,\n  gameGrid: counter[][],\n  turn: string\n) => {\n  for (let col = focalCol, row = minRow; row <= focalRow; row++) {\n    const winner = getWinner(\n      [row, col],\n      [row + 1, col],\n      [row + 2, col],\n      [row + 3, col],\n      gameGrid,\n      turn\n    );\n    if (winner) return winner;\n  }\n  return false;\n};\n// Check for all possible diagonal \\ near counter that were places\nconst checkForwardSlashSegments = (\n  { focalRow, focalCol, minRow, minCol, maxRow, maxCol }: coordinates,\n  gameGrid: counter[][],\n  turn: string\n) => {\n  const startForwardSlash = (row: number, col: number) => {\n    while (row > minRow && col > minCol) {\n      row--;\n      col--;\n    }\n    return [row, col];\n  };\n\n  for (\n    let [row, col] = startForwardSlash(focalRow, focalCol);\n    row <= maxRow && col <= maxCol;\n    row++, col++\n  ) {\n    const winner = getWinner(\n      [row, col],\n      [row + 1, col + 1],\n      [row + 2, col + 2],\n      [row + 3, col + 3],\n      gameGrid,\n      turn\n    );\n    if (winner) return winner;\n  }\n  return false;\n};\n// Check for all possible diagonal / near counter that were places\nconst checkBackwardSlashSegments = (\n  { focalRow, focalCol, minRow, minCol, maxRow, maxCol }: coordinates,\n  gameGrid: counter[][],\n  turn: string\n) => {\n  const startBackwardSlash = (row: number, col: number) => {\n    while (row < maxRow && col > minCol) {\n      row++;\n      col--;\n    }\n    return [row, col];\n  };\n  for (\n    let [row, col] = startBackwardSlash(focalRow, focalCol);\n    row >= minRow && col <= maxCol;\n    row--, col++\n  ) {\n    const winner = getWinner(\n      [row, col],\n      [row - 1, col + 1],\n      [row - 2, col + 2],\n      [row - 3, col + 3],\n      gameGrid,\n      turn\n    );\n    if (winner) return winner;\n  }\n  return false;\n};\n\nexport const checkForWin = (\n  focalRow: number,\n  focalCol: number,\n  gameGrid: counter[][],\n  turn: string\n) => {\n  // difenes min and max columns and rows for particular counter\n  //  0  1  2  3  4  5  6\n  // [ ][ ][ ][ ][ ][ ][ ] 0\n  // [x][our counter][x][x][ ][ ][ ] 1\n  // [ ][ ][ ][ ][ ][ ][ ] 2\n  // [ ][ ][ ][ ][ ][ ][ ] 3\n  // [ ][ ][ ][ ][ ][ ][ ] 4\n  // [ ][ ][ ][ ][ ][ ][ ] 5\n  const minCol = min(focalCol);\n  const maxCol = max(focalCol, 6);\n  const minRow = min(focalRow);\n  const maxRow = max(focalRow, 5);\n  const coords: coordinates = {\n    focalRow,\n    focalCol,\n    minRow,\n    minCol,\n    maxRow,\n    maxCol,\n  };\n\n  return (\n    checkHorizontalSegments(coords, gameGrid, turn) ||\n    checkVerticalSegments(coords, gameGrid, turn) ||\n    checkForwardSlashSegments(coords, gameGrid, turn) ||\n    checkBackwardSlashSegments(coords, gameGrid, turn)\n  );\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}