{"ast":null,"code":"import { getCounter } from './helpers';\nconst min = num => Math.max(num - 3, 0);\nconst max = (num, max) => Math.min(num + 3, max);\n\n// chek for win inspired by https://stackoverflow.com/questions/32770321/connect-4-check-for-a-win-algorithm\n\nconst getWinner = (firstSegment, secondSegment, thirdegment, fourthSegment, gameGrid, turn) => {\n  const segments = [firstSegment, secondSegment, thirdegment, fourthSegment];\n  // check if where is more then 4 coutners in segement\n  if (segments.length !== 4) return false;\n  let counters = segments.map(_ref => {\n    let [row, col] = _ref;\n    // get counter from game board\n    return getCounter(row, col, gameGrid);\n  });\n\n  // get color\n  const color = counters[0];\n  // if there is no color --> segment is not completed\n  if (!color) return false;\n  // if every color in segment is the same is win retrun\n  // winner color and win combo segemnts\n  if (counters.every(c => c === turn)) {\n    return {\n      winner: turn,\n      segments\n    };\n  }\n  return false;\n};\n\n// Check for all possible horizontal segmetns near counter that were places\nconst checkHorizontalSegments = (_ref2, gameGrid, turn) => {\n  let {\n    focalRow,\n    minCol,\n    maxCol,\n    focalCol\n  } = _ref2;\n  for (let row = focalRow, col = minCol; col <= maxCol; col++) {\n    // Check segment for win\n    const winner = getWinner([row, col], [row, col + 1], [row, col + 2], [row, col + 3], gameGrid, turn);\n    if (winner) return winner;\n  }\n  return false;\n};\n\n// Check for all possible vertical segmetns near counter that were places\n\nconst checkVerticalSegments = (_ref3, gameGrid, turn) => {\n  let {\n    focalRow,\n    focalCol,\n    minRow,\n    maxRow\n  } = _ref3;\n  for (let col = focalCol, row = minRow; row <= focalRow; row++) {\n    const winner = getWinner([row, col], [row + 1, col], [row + 2, col], [row + 3, col], gameGrid, turn);\n    if (winner) return winner;\n  }\n  return false;\n};\n// Check for all possible diagonal \\ near counter that were places\nconst checkForwardSlashSegments = (_ref4, gameGrid, turn) => {\n  let {\n    focalRow,\n    focalCol,\n    minRow,\n    minCol,\n    maxRow,\n    maxCol\n  } = _ref4;\n  const startForwardSlash = (row, col) => {\n    while (row > minRow && col > minCol) {\n      row--;\n      col--;\n    }\n    return [row, col];\n  };\n  for (let [row, col] = startForwardSlash(focalRow, focalCol); row <= maxRow && col <= maxCol; row++, col++) {\n    const winner = getWinner([row, col], [row + 1, col + 1], [row + 2, col + 2], [row + 3, col + 3], gameGrid, turn);\n    if (winner) return winner;\n  }\n  return false;\n};\n// Check for all possible diagonal / near counter that were places\nconst checkBackwardSlashSegments = (_ref5, gameGrid, turn) => {\n  let {\n    focalRow,\n    focalCol,\n    minRow,\n    minCol,\n    maxRow,\n    maxCol\n  } = _ref5;\n  const startBackwardSlash = (row, col) => {\n    while (row < maxRow && col > minCol) {\n      row++;\n      col--;\n    }\n    return [row, col];\n  };\n  for (let [row, col] = startBackwardSlash(focalRow, focalCol); row >= minRow && col <= maxCol; row--, col++) {\n    const winner = getWinner([row, col], [row - 1, col + 1], [row - 2, col + 2], [row - 3, col + 3], gameGrid, turn);\n    if (winner) return winner;\n  }\n  return false;\n};\nexport const checkForWin = (focalRow, focalCol, gameGrid, turn) => {\n  // difenes min and max columns and rows for particular counter\n  //  0  1  2  3  4  5  6\n  // [ ][ ][ ][ ][ ][ ][ ] 0\n  // [x][our counter][x][x][ ][ ][ ] 1\n  // [ ][ ][ ][ ][ ][ ][ ] 2\n  // [ ][ ][ ][ ][ ][ ][ ] 3\n  // [ ][ ][ ][ ][ ][ ][ ] 4\n  // [ ][ ][ ][ ][ ][ ][ ] 5\n  const minCol = min(focalCol);\n  const maxCol = max(focalCol, 6);\n  const minRow = min(focalRow);\n  const maxRow = max(focalRow, 5);\n  const coords = {\n    focalRow,\n    focalCol,\n    minRow,\n    minCol,\n    maxRow,\n    maxCol\n  };\n  return checkHorizontalSegments(coords, gameGrid, turn) || checkVerticalSegments(coords, gameGrid, turn) || checkForwardSlashSegments(coords, gameGrid, turn) || checkBackwardSlashSegments(coords, gameGrid, turn);\n};","map":{"version":3,"names":["getCounter","min","num","Math","max","getWinner","firstSegment","secondSegment","thirdegment","fourthSegment","gameGrid","turn","segments","length","counters","map","row","col","color","every","c","winner","checkHorizontalSegments","focalRow","minCol","maxCol","focalCol","checkVerticalSegments","minRow","maxRow","checkForwardSlashSegments","startForwardSlash","checkBackwardSlashSegments","startBackwardSlash","checkForWin","coords"],"sources":["C:/wamp64/www/gamereact11/src/helpers/checkForWin.ts"],"sourcesContent":["import { counter } from './helpers';\nimport { getCounter } from './helpers';\n\ntype coordinates = {\n  focalRow: number;\n  focalCol: number;\n  minRow: number;\n  minCol: number;\n  maxRow: number;\n  maxCol: number;\n};\n\ntype winComb = {\n  winner: string | null;\n  segments: number[][];\n};\n\nconst min = (num: number): number => Math.max(num - 3, 0);\nconst max = (num: number, max: number): number => Math.min(num + 3, max);\n\n// chek for win inspired by https://stackoverflow.com/questions/32770321/connect-4-check-for-a-win-algorithm\n\nconst getWinner = (\n  firstSegment: number[],\n  secondSegment: number[],\n  thirdegment: number[],\n  fourthSegment: number[],\n  gameGrid: counter[][],\n  turn: string\n): boolean | winComb => {\n  const segments = [firstSegment, secondSegment, thirdegment, fourthSegment];\n  // check if where is more then 4 coutners in segement\n  if (segments.length !== 4) return false;\n  let counters = segments.map(([row, col]) => {\n    // get counter from game board\n    return getCounter(row, col, gameGrid);\n  });\n\n  // get color\n  const color = counters[0];\n  // if there is no color --> segment is not completed\n  if (!color) return false;\n  // if every color in segment is the same is win retrun\n  // winner color and win combo segemnts\n  if (counters.every((c) => c === turn)) {\n    return { winner: turn, segments };\n  }\n\n  return false;\n};\n\n// Check for all possible horizontal segmetns near counter that were places\nconst checkHorizontalSegments = (\n  { focalRow, minCol, maxCol, focalCol }: coordinates,\n  gameGrid: counter[][],\n  turn: string\n) => {\n  for (let row = focalRow, col = minCol; col <= maxCol; col++) {\n    // Check segment for win\n    const winner = getWinner(\n      [row, col],\n      [row, col + 1],\n      [row, col + 2],\n      [row, col + 3],\n      gameGrid,\n      turn\n    );\n\n    if (winner) return winner;\n  }\n  return false;\n};\n\n// Check for all possible vertical segmetns near counter that were places\n\nconst checkVerticalSegments = (\n  { focalRow, focalCol, minRow, maxRow }: coordinates,\n  gameGrid: counter[][],\n  turn: string\n) => {\n  for (let col = focalCol, row = minRow; row <= focalRow; row++) {\n    const winner = getWinner(\n      [row, col],\n      [row + 1, col],\n      [row + 2, col],\n      [row + 3, col],\n      gameGrid,\n      turn\n    );\n    if (winner) return winner;\n  }\n  return false;\n};\n// Check for all possible diagonal \\ near counter that were places\nconst checkForwardSlashSegments = (\n  { focalRow, focalCol, minRow, minCol, maxRow, maxCol }: coordinates,\n  gameGrid: counter[][],\n  turn: string\n) => {\n  const startForwardSlash = (row: number, col: number) => {\n    while (row > minRow && col > minCol) {\n      row--;\n      col--;\n    }\n    return [row, col];\n  };\n\n  for (\n    let [row, col] = startForwardSlash(focalRow, focalCol);\n    row <= maxRow && col <= maxCol;\n    row++, col++\n  ) {\n    const winner = getWinner(\n      [row, col],\n      [row + 1, col + 1],\n      [row + 2, col + 2],\n      [row + 3, col + 3],\n      gameGrid,\n      turn\n    );\n    if (winner) return winner;\n  }\n  return false;\n};\n// Check for all possible diagonal / near counter that were places\nconst checkBackwardSlashSegments = (\n  { focalRow, focalCol, minRow, minCol, maxRow, maxCol }: coordinates,\n  gameGrid: counter[][],\n  turn: string\n) => {\n  const startBackwardSlash = (row: number, col: number) => {\n    while (row < maxRow && col > minCol) {\n      row++;\n      col--;\n    }\n    return [row, col];\n  };\n  for (\n    let [row, col] = startBackwardSlash(focalRow, focalCol);\n    row >= minRow && col <= maxCol;\n    row--, col++\n  ) {\n    const winner = getWinner(\n      [row, col],\n      [row - 1, col + 1],\n      [row - 2, col + 2],\n      [row - 3, col + 3],\n      gameGrid,\n      turn\n    );\n    if (winner) return winner;\n  }\n  return false;\n};\n\nexport const checkForWin = (\n  focalRow: number,\n  focalCol: number,\n  gameGrid: counter[][],\n  turn: string\n) => {\n  // difenes min and max columns and rows for particular counter\n  //  0  1  2  3  4  5  6\n  // [ ][ ][ ][ ][ ][ ][ ] 0\n  // [x][our counter][x][x][ ][ ][ ] 1\n  // [ ][ ][ ][ ][ ][ ][ ] 2\n  // [ ][ ][ ][ ][ ][ ][ ] 3\n  // [ ][ ][ ][ ][ ][ ][ ] 4\n  // [ ][ ][ ][ ][ ][ ][ ] 5\n  const minCol = min(focalCol);\n  const maxCol = max(focalCol, 6);\n  const minRow = min(focalRow);\n  const maxRow = max(focalRow, 5);\n  const coords: coordinates = {\n    focalRow,\n    focalCol,\n    minRow,\n    minCol,\n    maxRow,\n    maxCol,\n  };\n\n  return (\n    checkHorizontalSegments(coords, gameGrid, turn) ||\n    checkVerticalSegments(coords, gameGrid, turn) ||\n    checkForwardSlashSegments(coords, gameGrid, turn) ||\n    checkBackwardSlashSegments(coords, gameGrid, turn)\n  );\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}