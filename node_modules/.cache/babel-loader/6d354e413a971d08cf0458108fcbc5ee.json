{"ast":null,"code":"import{copyBoard}from'./helpers';import{boardScore}from'./boardScore';import{findRowToLandCounter}from'./findRowToLandCounter';import{boardIsFull}from'./helpers';export function maximizePlay(gameGrid,depth,gameScore,alpha,beta){var gameColumns=7;//  check current board score for cpu\nvar score=boardScore(gameGrid,gameScore);// stop calculation if\n// -we reached depth 0\n//  gameScore is Infinity cpu wins\n//  gameScore is -Infinity player wins\n//  there is no more space\nif(depth===0||score===gameScore||score===-gameScore||boardIsFull(gameGrid))return[null,score];// current best Column, Score\nvar max=[null,-Infinity];//   For all possible moves\nfor(var column=0;column<gameColumns;column++){var new_board=copyBoard(gameGrid);// Create new board\nvar row=findRowToLandCounter(new_board,column);//  check if this place if empty\nif(!new_board[row][column]){// plave counter in empty position\nnew_board[row][column]='yellow';var next_move=minimizePlay(new_board,depth-1,gameScore,alpha,beta);// Recursive calling\n// Evaluate new move\nif(max[0]===null||next_move[1]>max[1]){max[0]=column;max[1]=next_move[1];alpha=next_move[1];}// @ts-ignore\nif(alpha>=beta)return max;}}return max;}export function minimizePlay(gameGrid,depth,gameScore,alpha,beta){var gameColumns=7;//  check current board score for cpu\nvar score=boardScore(gameGrid,gameScore);// stop calculation if\n// -we reached depth 0\n//  gameScore is Infinity cpu wins\n//  gameScore is -Infinity player wins\n//  there is no more space\nif(depth===0||score===gameScore||score===-gameScore||boardIsFull(gameGrid))return[null,score];// current best Column, Score\nvar min=[null,Infinity];//   For all possible moves\nfor(var column=0;column<gameColumns;column++){// creating new board\nvar new_board=copyBoard(gameGrid);// findig row to place counter\nvar row=findRowToLandCounter(new_board,column);//  check if this place if empty\nif(!new_board[row][column]){new_board[row][column]='red';var next_move=maximizePlay(new_board,depth-1,gameScore,alpha,beta);// Evaluate new move\nif(min[0]==null||next_move[1]<min[1]){min[0]=column;min[1]=next_move[1];beta=next_move[1];}// @ts-ignore\nif(alpha>=beta)return min;}}return min;}","map":{"version":3,"names":["copyBoard","boardScore","findRowToLandCounter","boardIsFull","maximizePlay","gameGrid","depth","gameScore","alpha","beta","gameColumns","score","max","Infinity","column","new_board","row","next_move","minimizePlay","min"],"sources":["C:/wamp64/www/gamereact11/src/helpers/aiMove.ts"],"sourcesContent":["import { counter } from './helpers';\nimport { copyBoard } from './helpers';\nimport { boardScore } from './boardScore';\nimport { findRowToLandCounter } from './findRowToLandCounter';\nimport { boardIsFull } from './helpers';\n\nexport function maximizePlay(\n  gameGrid: counter[][],\n  depth: number,\n  gameScore: number,\n  alpha?: number,\n  beta?: number\n): [null | number, number] {\n  let gameColumns = 7;\n  //  check current board score for cpu\n  const score = boardScore(gameGrid, gameScore);\n  // stop calculation if\n  // -we reached depth 0\n  //  gameScore is Infinity cpu wins\n  //  gameScore is -Infinity player wins\n  //  there is no more space\n  if (\n    depth === 0 ||\n    score === gameScore ||\n    score === -gameScore ||\n    boardIsFull(gameGrid)\n  )\n    return [null, score];\n\n  // current best Column, Score\n  let max: [null | number, number] = [null, -Infinity];\n\n  //   For all possible moves\n  for (let column = 0; column < gameColumns; column++) {\n    let new_board = copyBoard(gameGrid); // Create new board\n    const row = findRowToLandCounter(new_board, column);\n    //  check if this place if empty\n    if (!new_board[row][column]) {\n      // plave counter in empty position\n      new_board[row][column] = 'yellow';\n\n      let next_move = minimizePlay(\n        new_board,\n        depth - 1,\n        gameScore,\n        alpha,\n        beta\n      ); // Recursive calling\n\n      // Evaluate new move\n      if (max[0] === null || next_move[1] > max[1]) {\n        max[0] = column;\n        max[1] = next_move[1];\n\n        alpha = next_move[1];\n      }\n      // @ts-ignore\n      if (alpha >= beta) return max;\n    }\n  }\n\n  return max;\n}\n\nexport function minimizePlay(\n  gameGrid: counter[][],\n  depth: number,\n  gameScore: number,\n  alpha?: number,\n  beta?: number\n): [null | number, number] {\n  let gameColumns = 7;\n  //  check current board score for cpu\n  const score = boardScore(gameGrid, gameScore);\n  // stop calculation if\n  // -we reached depth 0\n  //  gameScore is Infinity cpu wins\n  //  gameScore is -Infinity player wins\n  //  there is no more space\n  if (\n    depth === 0 ||\n    score === gameScore ||\n    score === -gameScore ||\n    boardIsFull(gameGrid)\n  )\n    return [null, score];\n  // current best Column, Score\n  let min: [null | number, number] = [null, Infinity];\n  //   For all possible moves\n  for (let column = 0; column < gameColumns; column++) {\n    // creating new board\n    let new_board = copyBoard(gameGrid);\n    // findig row to place counter\n    const row = findRowToLandCounter(new_board, column);\n    //  check if this place if empty\n    if (!new_board[row][column]) {\n      new_board[row][column] = 'red';\n\n      let next_move = maximizePlay(\n        new_board,\n        depth - 1,\n        gameScore,\n        alpha,\n        beta\n      );\n      // Evaluate new move\n      if (min[0] == null || next_move[1] < min[1]) {\n        min[0] = column;\n        min[1] = next_move[1];\n\n        beta = next_move[1];\n      }\n      // @ts-ignore\n      if (alpha >= beta) return min;\n    }\n  }\n\n  return min;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}