{"ast":null,"code":"import { copyBoard } from './helpers';\nimport { boardScore } from './boardScore';\nimport { findRowToLandCounter } from './findRowToLandCounter';\nimport { boardIsFull } from './helpers';\nexport function maximizePlay(gameGrid, depth, gameScore, alpha, beta) {\n  let gameColumns = 7;\n  //  check current board score for cpu\n  const score = boardScore(gameGrid, gameScore);\n  // stop calculation if\n  // -we reached depth 0\n  //  gameScore is Infinity cpu wins\n  //  gameScore is -Infinity player wins\n  //  there is no more space\n  if (depth === 0 || score === gameScore || score === -gameScore || boardIsFull(gameGrid)) return [null, score];\n\n  // current best Column, Score\n  let max = [null, -Infinity];\n\n  //   For all possible moves\n  for (let column = 0; column < gameColumns; column++) {\n    let new_board = copyBoard(gameGrid); // Create new board\n    const row = findRowToLandCounter(new_board, column);\n    //  check if this place if empty\n    if (!new_board[row][column]) {\n      // plave counter in empty position\n      new_board[row][column] = 'yellow';\n      let next_move = minimizePlay(new_board, depth - 1, gameScore, alpha, beta); // Recursive calling\n\n      // Evaluate new move\n      if (max[0] === null || next_move[1] > max[1]) {\n        max[0] = column;\n        max[1] = next_move[1];\n        alpha = next_move[1];\n      }\n      // @ts-ignore\n      if (alpha >= beta) return max;\n    }\n  }\n  return max;\n}\nexport function minimizePlay(gameGrid, depth, gameScore, alpha, beta) {\n  let gameColumns = 7;\n  //  check current board score for cpu\n  const score = boardScore(gameGrid, gameScore);\n  // stop calculation if\n  // -we reached depth 0\n  //  gameScore is Infinity cpu wins\n  //  gameScore is -Infinity player wins\n  //  there is no more space\n  if (depth === 0 || score === gameScore || score === -gameScore || boardIsFull(gameGrid)) return [null, score];\n  // current best Column, Score\n  let min = [null, Infinity];\n  //   For all possible moves\n  for (let column = 0; column < gameColumns; column++) {\n    // creating new board\n    let new_board = copyBoard(gameGrid);\n    // findig row to place counter\n    const row = findRowToLandCounter(new_board, column);\n    //  check if this place if empty\n    if (!new_board[row][column]) {\n      new_board[row][column] = 'red';\n      let next_move = maximizePlay(new_board, depth - 1, gameScore, alpha, beta);\n      // Evaluate new move\n      if (min[0] == null || next_move[1] < min[1]) {\n        min[0] = column;\n        min[1] = next_move[1];\n        beta = next_move[1];\n      }\n      // @ts-ignore\n      if (alpha >= beta) return min;\n    }\n  }\n  return min;\n}","map":{"version":3,"names":["copyBoard","boardScore","findRowToLandCounter","boardIsFull","maximizePlay","gameGrid","depth","gameScore","alpha","beta","gameColumns","score","max","Infinity","column","new_board","row","next_move","minimizePlay","min"],"sources":["C:/wamp64/www/gamereact11/src/helpers/aiMove.ts"],"sourcesContent":["import { counter } from './helpers';\nimport { copyBoard } from './helpers';\nimport { boardScore } from './boardScore';\nimport { findRowToLandCounter } from './findRowToLandCounter';\nimport { boardIsFull } from './helpers';\n\nexport function maximizePlay(\n  gameGrid: counter[][],\n  depth: number,\n  gameScore: number,\n  alpha?: number,\n  beta?: number\n): [null | number, number] {\n  let gameColumns = 7;\n  //  check current board score for cpu\n  const score = boardScore(gameGrid, gameScore);\n  // stop calculation if\n  // -we reached depth 0\n  //  gameScore is Infinity cpu wins\n  //  gameScore is -Infinity player wins\n  //  there is no more space\n  if (\n    depth === 0 ||\n    score === gameScore ||\n    score === -gameScore ||\n    boardIsFull(gameGrid)\n  )\n    return [null, score];\n\n  // current best Column, Score\n  let max: [null | number, number] = [null, -Infinity];\n\n  //   For all possible moves\n  for (let column = 0; column < gameColumns; column++) {\n    let new_board = copyBoard(gameGrid); // Create new board\n    const row = findRowToLandCounter(new_board, column);\n    //  check if this place if empty\n    if (!new_board[row][column]) {\n      // plave counter in empty position\n      new_board[row][column] = 'yellow';\n\n      let next_move = minimizePlay(\n        new_board,\n        depth - 1,\n        gameScore,\n        alpha,\n        beta\n      ); // Recursive calling\n\n      // Evaluate new move\n      if (max[0] === null || next_move[1] > max[1]) {\n        max[0] = column;\n        max[1] = next_move[1];\n\n        alpha = next_move[1];\n      }\n      // @ts-ignore\n      if (alpha >= beta) return max;\n    }\n  }\n\n  return max;\n}\n\nexport function minimizePlay(\n  gameGrid: counter[][],\n  depth: number,\n  gameScore: number,\n  alpha?: number,\n  beta?: number\n): [null | number, number] {\n  let gameColumns = 7;\n  //  check current board score for cpu\n  const score = boardScore(gameGrid, gameScore);\n  // stop calculation if\n  // -we reached depth 0\n  //  gameScore is Infinity cpu wins\n  //  gameScore is -Infinity player wins\n  //  there is no more space\n  if (\n    depth === 0 ||\n    score === gameScore ||\n    score === -gameScore ||\n    boardIsFull(gameGrid)\n  )\n    return [null, score];\n  // current best Column, Score\n  let min: [null | number, number] = [null, Infinity];\n  //   For all possible moves\n  for (let column = 0; column < gameColumns; column++) {\n    // creating new board\n    let new_board = copyBoard(gameGrid);\n    // findig row to place counter\n    const row = findRowToLandCounter(new_board, column);\n    //  check if this place if empty\n    if (!new_board[row][column]) {\n      new_board[row][column] = 'red';\n\n      let next_move = maximizePlay(\n        new_board,\n        depth - 1,\n        gameScore,\n        alpha,\n        beta\n      );\n      // Evaluate new move\n      if (min[0] == null || next_move[1] < min[1]) {\n        min[0] = column;\n        min[1] = next_move[1];\n\n        beta = next_move[1];\n      }\n      // @ts-ignore\n      if (alpha >= beta) return min;\n    }\n  }\n\n  return min;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}