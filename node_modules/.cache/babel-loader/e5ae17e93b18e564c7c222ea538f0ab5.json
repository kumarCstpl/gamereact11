{"ast":null,"code":"import { createSlice, current } from '@reduxjs/toolkit';\nimport { boardIsFull, createGrid } from '../helpers/helpers';\nimport { findRowToLandCounter } from '../helpers/findRowToLandCounter';\nimport { checkForWin } from '../helpers/checkForWin';\nconst initialState = {\n  gameIsRunning: false,\n  gameMode: '',\n  p1: {\n    name: '',\n    color: 'red',\n    score: 0\n  },\n  p2: {\n    name: '',\n    color: 'yellow',\n    score: 0\n  },\n  turn: 'red',\n  gameBoard: createGrid(),\n  winner: null,\n  timer: 30,\n  currentPlayer: 'p1',\n  isGamePaused: false,\n  starterColor: 'red',\n  isTimeForNextTurn: true,\n  winnigComb: {},\n  CPULevel: 4,\n  pointerColumn: '0'\n};\nconst gameSlice = createSlice({\n  name: 'game',\n  initialState,\n  reducers: {\n    startGame(state, action) {\n      state.gameMode = action.payload;\n      state.p1.name = action.payload === 'PvP' ? 'Player 1' : 'You';\n      state.p2.name = action.payload === 'PvP' ? 'Player 2' : 'CPU';\n      state.currentPlayer = state.p1.color === state.turn ? 'p1' : 'p2';\n      state.gameIsRunning = true;\n    },\n    placeCounter(state, action) {\n      const col = action.payload.col;\n      const row = action.payload.row;\n      state.gameBoard[row][col] = state.turn;\n    },\n    changeTurn(state) {\n      state.turn = state.turn === 'red' ? 'yellow' : 'red';\n      state.timer = 30;\n      state.currentPlayer = state.p1.color === state.turn ? 'p1' : 'p2';\n    },\n    checkForWinner(state, action) {\n      const {\n        gameBoard\n      } = current(state);\n      const col = action.payload.col;\n      const row = action.payload.row;\n      const winnerComb = checkForWin(row, col, gameBoard, state.turn);\n      if (typeof winnerComb !== 'boolean' && winnerComb.winner) {\n        const {\n          winner,\n          segments\n        } = winnerComb;\n        state.winner = state.p1.color === winner ? 'p1' : 'p2';\n        state[state.winner].score++;\n        segments.forEach(seg => state.winnigComb[`${seg[0]}${seg[1]}`] = true);\n        state.isGamePaused = true;\n      }\n    },\n    updateTimer(state, action) {\n      state.timer = action.payload;\n    },\n    playAgain(state) {\n      state.gameBoard = createGrid();\n      state.timer = 30;\n      state.isGamePaused = false;\n      state.winnigComb = {};\n      // change turn color to color that was second in previous round\n      state.turn = state.starterColor === 'red' ? 'yellow' : 'red';\n      state.starterColor = state.starterColor === 'red' ? 'yellow' : 'red';\n      state.currentPlayer = state.p1.color === state.turn ? 'p1' : 'p2';\n      state.winner = null;\n    },\n    restartGame(state) {\n      state.gameBoard = createGrid();\n      state.timer = 30;\n      state.isGamePaused = false;\n      state.winnigComb = {};\n      // return initial turn color\n      state.turn = state.starterColor;\n      state.currentPlayer = state.p1.color === state.turn ? 'p1' : 'p2';\n      state.winner = null;\n    },\n    quitGame: () => initialState,\n    pauseGame(state) {\n      state.isGamePaused = true;\n    },\n    continueGame(state) {\n      state.isGamePaused = false;\n    },\n    setIsTimeToNextTurn(state, action) {\n      state.isTimeForNextTurn = action.payload;\n    },\n    setCPULevel(state, action) {\n      state.CPULevel = action.payload;\n    },\n    setWinner(state, action) {\n      state.winner = action.payload;\n    },\n    checkForTie(state) {\n      if (boardIsFull(state.gameBoard)) {\n        state.winner = 'tie';\n      }\n    },\n    setPointercolumn(state, action) {\n      state.pointerColumn = action.payload;\n    }\n  }\n});\n\n// exporting all actions that we need\nexport const {\n  startGame,\n  placeCounter,\n  changeTurn,\n  checkForWinner,\n  updateTimer,\n  playAgain,\n  pauseGame,\n  continueGame,\n  restartGame,\n  quitGame,\n  setIsTimeToNextTurn,\n  setCPULevel,\n  setWinner,\n  checkForTie,\n  setPointercolumn\n} = gameSlice.actions;\n\n// exporting all states that we need\nexport const selectGameIsRunning = state => state.game.gameIsRunning;\nexport const selectPlayer1 = state => state.game.p1;\nexport const selectPlayer2 = state => state.game.p2;\nexport const selectTurn = state => state.game.turn;\nexport const selectGameBoard = state => state.game.gameBoard;\nexport const selectWinner = state => state.game.winner;\nexport const selectGameMode = state => state.game.gameMode;\nexport const selectTimer = state => state.game.timer;\nexport const selectPointerColumn = state => state.game.pointerColumn;\nexport const selectIsTimeForNextTurn = state => state.game.isTimeForNextTurn;\nexport const selectWinnigCombination = state => state.game.winnigComb;\nexport const selectIsGamePaused = state => state.game.isGamePaused;\nexport const selectCurrentPlayer = state => state.game.currentPlayer;\n\n// exporting reducer\nexport const gameReducer = gameSlice.reducer;\nexport const makeMove = col => {\n  return (dispatch, getState) => {\n    // getting current game settings\n    const {\n      game\n    } = getState();\n    const gameBoard = game.gameBoard;\n    // if column is full or there is a winner or animation is in process when return false\n    if (gameBoard[0][col] || game.winner || !game.isTimeForNextTurn) return false;\n    // set time to next turn to false to prevent amking move before end of animation\n    dispatch(setIsTimeToNextTurn(false));\n    // getting row in column with empty cell\n    const row = findRowToLandCounter(gameBoard, col);\n    // place counter\n    dispatch(placeCounter({\n      col,\n      row\n    }));\n    // checkforwin\n    dispatch(checkForWinner({\n      col,\n      row\n    }));\n    // checking for tie\n    dispatch(checkForTie());\n    // change turn\n    dispatch(changeTurn());\n    // after 0.4s we set time to next turn to true\n    // we need this time to make sure that counter animation is finished\n    setTimeout(() => {\n      dispatch(setIsTimeToNextTurn(true));\n    }, 400);\n    return true;\n  };\n};","map":{"version":3,"names":["createSlice","current","boardIsFull","createGrid","findRowToLandCounter","checkForWin","initialState","gameIsRunning","gameMode","p1","name","color","score","p2","turn","gameBoard","winner","timer","currentPlayer","isGamePaused","starterColor","isTimeForNextTurn","winnigComb","CPULevel","pointerColumn","gameSlice","reducers","startGame","state","action","payload","placeCounter","col","row","changeTurn","checkForWinner","winnerComb","segments","forEach","seg","updateTimer","playAgain","restartGame","quitGame","pauseGame","continueGame","setIsTimeToNextTurn","setCPULevel","setWinner","checkForTie","setPointercolumn","actions","selectGameIsRunning","game","selectPlayer1","selectPlayer2","selectTurn","selectGameBoard","selectWinner","selectGameMode","selectTimer","selectPointerColumn","selectIsTimeForNextTurn","selectWinnigCombination","selectIsGamePaused","selectCurrentPlayer","gameReducer","reducer","makeMove","dispatch","getState","setTimeout"],"sources":["C:/wamp64/www/connect-four-game-main/src/store/gameSlice.ts"],"sourcesContent":["import { createSlice, PayloadAction, current } from '@reduxjs/toolkit';\nimport { RootState } from './store';\nimport { boardIsFull, createGrid } from '../helpers/helpers';\nimport { findRowToLandCounter } from '../helpers/findRowToLandCounter';\nimport { counter } from '../helpers/helpers';\nimport { store } from './store';\nimport { checkForWin } from '../helpers/checkForWin';\n\ntype player = {\n  name: string;\n  color: string;\n  score: number;\n};\n\ntype inintialStateType = {\n  [key: string]: any;\n  gameIsRunning: boolean;\n  gameMode: string;\n  p1: player;\n  p2: player;\n  turn: string;\n  gameBoard: counter[][];\n  winner: string | null;\n  timer: number;\n  currentPlayer: string;\n  isGamePaused: boolean;\n  starterColor: string;\n  isTimeForNextTurn: boolean;\n  CPULevel: number;\n  winnigComb: {\n    [key: string]: boolean;\n  };\n  pointerColumn: string;\n};\n\nconst initialState: inintialStateType = {\n  gameIsRunning: false,\n  gameMode: '',\n  p1: {\n    name: '',\n    color: 'red',\n    score: 0,\n  },\n  p2: {\n    name: '',\n    color: 'yellow',\n    score: 0,\n  },\n  turn: 'red',\n  gameBoard: createGrid(),\n  winner: null,\n  timer: 30,\n  currentPlayer: 'p1',\n  isGamePaused: false,\n  starterColor: 'red',\n  isTimeForNextTurn: true,\n  winnigComb: {},\n  CPULevel: 4,\n  pointerColumn: '0',\n};\n\nconst gameSlice = createSlice({\n  name: 'game',\n  initialState,\n  reducers: {\n    startGame(state, action: PayloadAction<string>) {\n      state.gameMode = action.payload;\n      state.p1.name = action.payload === 'PvP' ? 'Player 1' : 'You';\n      state.p2.name = action.payload === 'PvP' ? 'Player 2' : 'CPU';\n      state.currentPlayer = state.p1.color === state.turn ? 'p1' : 'p2';\n      state.gameIsRunning = true;\n    },\n    placeCounter(state, action: PayloadAction<{ col: number; row: number }>) {\n      const col = action.payload.col;\n      const row = action.payload.row;\n\n      state.gameBoard[row][col] = state.turn;\n    },\n    changeTurn(state) {\n      state.turn = state.turn === 'red' ? 'yellow' : 'red';\n      state.timer = 30;\n      state.currentPlayer = state.p1.color === state.turn ? 'p1' : 'p2';\n    },\n\n    checkForWinner(state, action: PayloadAction<{ col: number; row: number }>) {\n      const { gameBoard } = current(state);\n      const col = action.payload.col;\n      const row = action.payload.row;\n\n      const winnerComb = checkForWin(row, col, gameBoard, state.turn);\n      if (typeof winnerComb !== 'boolean' && winnerComb.winner) {\n        const { winner, segments } = winnerComb;\n        state.winner = state.p1.color === winner ? 'p1' : 'p2';\n        state[state.winner].score++;\n        segments.forEach(\n          (seg) => (state.winnigComb[`${seg[0]}${seg[1]}`] = true)\n        );\n        state.isGamePaused = true;\n      }\n    },\n    updateTimer(state, action: PayloadAction<number>) {\n      state.timer = action.payload;\n    },\n\n    playAgain(state) {\n      state.gameBoard = createGrid();\n      state.timer = 30;\n      state.isGamePaused = false;\n      state.winnigComb = {};\n      // change turn color to color that was second in previous round\n      state.turn = state.starterColor === 'red' ? 'yellow' : 'red';\n      state.starterColor = state.starterColor === 'red' ? 'yellow' : 'red';\n      state.currentPlayer = state.p1.color === state.turn ? 'p1' : 'p2';\n      state.winner = null;\n    },\n\n    restartGame(state) {\n      state.gameBoard = createGrid();\n      state.timer = 30;\n      state.isGamePaused = false;\n      state.winnigComb = {};\n      // return initial turn color\n      state.turn = state.starterColor;\n\n      state.currentPlayer = state.p1.color === state.turn ? 'p1' : 'p2';\n      state.winner = null;\n    },\n\n    quitGame: () => initialState,\n\n    pauseGame(state) {\n      state.isGamePaused = true;\n    },\n    continueGame(state) {\n      state.isGamePaused = false;\n    },\n    setIsTimeToNextTurn(state, action: PayloadAction<boolean>) {\n      state.isTimeForNextTurn = action.payload;\n    },\n    setCPULevel(state, action: PayloadAction<number>) {\n      state.CPULevel = action.payload;\n    },\n    setWinner(state, action: PayloadAction<string>) {\n      state.winner = action.payload;\n    },\n    checkForTie(state) {\n      if (boardIsFull(state.gameBoard)) {\n        state.winner = 'tie';\n      }\n    },\n    setPointercolumn(state, action: PayloadAction<string>) {\n      state.pointerColumn = action.payload;\n    },\n  },\n});\n\n// exporting all actions that we need\nexport const {\n  startGame,\n  placeCounter,\n  changeTurn,\n  checkForWinner,\n  updateTimer,\n  playAgain,\n  pauseGame,\n  continueGame,\n  restartGame,\n  quitGame,\n  setIsTimeToNextTurn,\n  setCPULevel,\n  setWinner,\n  checkForTie,\n  setPointercolumn,\n} = gameSlice.actions;\n\n// exporting all states that we need\nexport const selectGameIsRunning = (state: RootState) =>\n  state.game.gameIsRunning;\nexport const selectPlayer1 = (state: RootState) => state.game.p1;\nexport const selectPlayer2 = (state: RootState) => state.game.p2;\nexport const selectTurn = (state: RootState) => state.game.turn;\nexport const selectGameBoard = (state: RootState) => state.game.gameBoard;\nexport const selectWinner = (state: RootState) => state.game.winner;\nexport const selectGameMode = (state: RootState) => state.game.gameMode;\nexport const selectTimer = (state: RootState) => state.game.timer;\nexport const selectPointerColumn = (state: RootState) =>\n  state.game.pointerColumn;\nexport const selectIsTimeForNextTurn = (state: RootState) =>\n  state.game.isTimeForNextTurn;\nexport const selectWinnigCombination = (state: RootState) =>\n  state.game.winnigComb;\nexport const selectIsGamePaused = (state: RootState) => state.game.isGamePaused;\nexport const selectCurrentPlayer = (state: RootState) =>\n  state.game.currentPlayer;\n\n// exporting reducer\nexport const gameReducer = gameSlice.reducer;\n\nexport const makeMove = (col: number) => {\n  return (\n    dispatch: typeof store.dispatch,\n    getState: typeof store.getState\n  ): boolean => {\n    // getting current game settings\n    const { game } = getState();\n    const gameBoard = game.gameBoard;\n    // if column is full or there is a winner or animation is in process when return false\n    if (gameBoard[0][col] || game.winner || !game.isTimeForNextTurn)\n      return false;\n    // set time to next turn to false to prevent amking move before end of animation\n    dispatch(setIsTimeToNextTurn(false));\n    // getting row in column with empty cell\n    const row = findRowToLandCounter(gameBoard, col);\n    // place counter\n    dispatch(placeCounter({ col, row }));\n    // checkforwin\n    dispatch(checkForWinner({ col, row }));\n    // checking for tie\n    dispatch(checkForTie());\n    // change turn\n    dispatch(changeTurn());\n    // after 0.4s we set time to next turn to true\n    // we need this time to make sure that counter animation is finished\n    setTimeout(() => {\n      dispatch(setIsTimeToNextTurn(true));\n    }, 400);\n    return true;\n  };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}